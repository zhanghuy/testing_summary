#### 1. 进程和线程的区别
进程：操作系统资源分配的基本单位；线程：spu任务调度和执行的基本单位。
区别
* 执行过程：每个进程有个程序运行入口，顺序执行序列；线程不能独立运行，由进程提供多个线程执行控制；
* 资源：进程间地址空间和资源（内存、i/o）独立;线程共享本进程的地址空间和资源；
* 开销：由于进程独立的地址和资源，切换程序会有较大的开销；同一进程下的线程由于共享地址空间和资源，线程质检切换的开销较小。（每个线程有独立的运行栈和程序计数器PC）
* 并发和并行：进程之间相互独立可以并行多个进程；单核cpu同一时刻支持执行一个线程，所以线程不能并行只能并发。（，多线程并发事实上就是多个线程排队申请调用CPU，CPU执行速度很多，所以看上去是多个线程任务说是并发处理。）
> **[协程](https://www.zhihu.com/question/342261454/answer/800062080)**: 是一种比线程更轻量级的存在，一个线程也可以拥有多个进程, 协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行） yield 是python当中的语法。当协程执行到yield关键字时，会暂停在那一行，等到主线程调用send方法发送了数据，协程才会接到数据继续执行。但是，yield让协程暂停，和线程的阻塞是有本质区别的。协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。因此，协程的开销远远小于线程的开销。

#### 2. http和https的区别   [HTTP是基于TCP/IP的关于数据如何在万维网中通信的协议]
* http：超文本传输协议，http是明文传输；
* https 在http上加入SSL加密传输协议+CA认证（SSL+HTTP构建的可进行加密传输和身份认证的网络协议），所以https密文传输数据更安全；
* http默认端口80，https协议的默认端口是443

 ##### 2.1 HTTP协议的主bai要特点可概括如下：
 1. 支持客户/服务器模式du。
 2. 简单快速zhi：客户向服务器请求服务时，只需传dao送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。
    由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
 3. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
 4. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
 5. 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在     服务器不需要先前信息时它的应答就较快。
 
 ##### 2.2 HTTP几种请求方法：
 1. GET 请求指定的页面信息，并返回实体主体。
 2. HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
 3. POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。
 4. PUT 从客户端向服务器传送的数据取代指定的文档的内容。
 5. DELETE 请求服务器删除指定的页面。 
 6. CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。
 7. OPTIONS 允许客户端查看服务器的性能。
 8. TRACE 回显服务器收到的请求，主要用于测试或诊断。
 9. PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。

 ##### 2.3 HTTP请求头和常见状态码：
 ![请求头](https://github.com/zhanghuy/testing_summary/blob/main/pic/http%E8%AF%B7%E6%B1%82%E5%A4%B4.jpg)
 ![状态码](https://github.com/zhanghuy/testing_summary/blob/main/pic/%E7%8A%B6%E6%80%81%E7%A0%81.jpg)
 100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息. 
200  OK   正常返回信息. 
201  Created  请求成功并且服务器创建了新的资源. 
202  Accepted  服务器已接受请求，但尚未处理. 
301  Moved Permanently  请求的网页已永久移动到新位置。  
302 Found  临时性重定向。  
303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。  
304  Not Modified  自从上次请求后，请求的网页未修改过。
400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401 Unauthorized  请求未授权。
403 Forbidden  禁止访问。
404 Not Found  找不到如何与 URI 相匹配的资源。
500 Internal Server Error  最常见的服务器端错误。
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。

#### 3. 三次握手和四次挥手
* 三次握手：第一次客户端向服务端发送SYN=1,seq=x的数据包；
  第二次服务端收到客户端的联机请求后，向客户端发送ACK=1，seq=x+1且SYN=1，seq=y的数据包；
  第三次客户端收到服务端发送的请求后，检查服务端发来的请求中的ACK=1的seq=x+1后向服务端发送ACK=1，seq=y+1的确认数据包
* 四次挥手：客户端向服务端发送FIN=1,seq=x的断开连接请求包，并进入FIN_WAIT_1状态；
  服务端收到请求后向客户端发送ACK=1,seq=x+1的请求，并进入Close_Wait状态等待应用程序关闭；客户端收到服务端发送的确认消息后，进入FIN_WAIT_2状态；
  服务端准备好断开连接后，向客户端发送FIN=1&seq=y的请求，并进入Last_ACK状态；
  客户端收到服务端的断开连接请求后，向服务器发送ACK&seq=y+1的确认消息，并进入TIME_WAIT状态（经过两个MSL后进入COLSED状态）；服务端收到确认消息后进入CLOSED状态。
  > TIME_WAIT:为了防止最后的ACK包丢失，客户端需维护一段事件的TCP状态信息，以便ACK包丢失的服务端重新发送FIN包后再次发送ACK包。
  > MSL:报文在网络中存在的最长的时间
  
#### 4. Get和Post的区别
* get参数包含在URL中，post通过request body传参：
  所以post更安全，参数不会被缓存/发送的数据更大更多类型/但是相对get请求慢一些；
  get请求效率更高/参数会被缓存/暴漏在url中不安全/发送数据大小和类型受限2kB ASCII字符；
  get产生一个数据包：把header和data一起发送，服务器响应200（返回数据）；post发送两个数据包：先发送header，服务器响应100，再发送data，服务器响应200（返回数据）
* 应用：因为post更安全—用post方式提交数据：比如一些需要写入或者修改数据的请求；
  多用get方式查询数据
  
#### 5. Cookie和Session区别
* cookie存放在客户端（单个cookie<=4kB, 不安全会被拦截）；session存放在服务器上（占用服务器存储空间，降低服务器性能）；
* cookie没有session安全，会被拦截，而session暴漏在网络传输中的只有sessionid，但sessionid只用用户登陆才会生成且会被服务端加密，而且session也有一定的有效期；

#### 6. 从输入URL到页面加载发生了什么
DNS解析域名为IP——>建立TCP连接——>浏览器向IP服务器发送请求——>服务器处理请求并返回数据——>浏览器解析渲染页面
详细参考：[从输入URL到页面加载发生了什么](https://www.jianshu.com/p/a877684a4cdd) 
> DNS负载均衡—DNS返回一个合适的机器IP给用户，例如根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。
> CDN（内容分发网络）节点由两部分组成：负载均衡设备和高速缓存服务器。

#### 7. 死锁
产生死锁的情况： 
1)对同一把互斥锁加锁了多次 
2)有多把锁，被不同线程或进程所持有，就会导致相互等待对方释放，程序就会卡死
对于第二种情况的解决方案： 1)抢锁一定按照顺序抢 2)给锁加上超时，如果超时则放弃执行

####  8. 进程间的通信方式
1. **管道pipe**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. **命名管道FIFO**：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. **消息队列MessageQueue**：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4. **共享存储SharedMemory**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
5. **信号量Semaphore**：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6. **套接字Socket**：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
7. **信号 (sinal)** ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

####  9. 线程之间通信
1. `threading.Lock()` 如果多个线程对某一资源同时进行修改，可能会存在不可预知的情况。为了修改数据的正确性，需要把这个资源锁住，只允许线程依次排队进去获取这个资源。当线程A操作完后，释放锁，线程B才能进入。如下脚本是开启多个线程修改变量的值，但输出结果每次都不一样。
2. `threading.Rlock()` 用法和 `threading Lock()` 一致，区别是 `threading.Rlock()` 允许多次锁资源，`cquire()` 和 `release()` 必须成对出现，也就是说加了几把锁就得释放几把锁。
3. `threading.Condition()` `threading.Condition()` 可以理解为更加高级的锁，比 Lock 和 Rlock 的用法更高级，能处理一些复杂的线程同步问题。`threading.Condition()` 创建一把资源锁（默认是Rlock），提供 `acquire()` 和 `release()` 方法，用法和 Rlock 一致。此外 `Condition` 还提供 `wait()`、`Notify()` 和 `NotifyAll()` 方法。
`wait()`：线程挂起，直到收到一个 `Notify()` 通知或者超时（可选参数），`wait()` 必须在线程得到 Rlock 后才能使用。
`Notify()` ：在线程挂起的时候，发送一个通知，让 `wait()` 等待线程继续运行，`Notify()` 也必须在线程得到 Rlock 后才能使用。 Notify(n=1)，最多唤醒 n 个线程。
`NotifyAll()` ：在线程挂起的时候，发送通知，让所有 `wait()` 阻塞的线程都继续运行。
4. `threading.Event()` `threading.Event()` 原理是在线程中立了一个 Flag ，默认值是 False ，当一个或多个线程遇到 `event.wait()` 方法时阻塞，直到 Flag 值 变为 True 。`threading.Event()` 通常用来实现线程之间的通信，使一个线程等待其他线程的通知 ，把 Event 传递到线程对象中。
`event.wait()` ：阻塞线程，直到 Flag 值变为 True
`event.set()` ：设置 Flag 值为 True
`event.clear()` ：修改 Flag 值为 False
`event.isSet()` : 仅当 Flag 值为 True 时返回
